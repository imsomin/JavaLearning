<0804>

1. 사용한 웹 컨테이너 : 톰캣8.5  
  클라이언트의 요청에 따른 리소스를 찾고  
  자바 코드를 html 코드로 변환하여 응답 및 전송해주는 임무 수행  


2. 통합 개발 환경(IDE), 코드를 작성하고 빌드해줄 수 있는 툴 : 이클립스  


3. Servelt : 자바 코드에 html 삽입(용도 : 처리)  
    JSP : html 내에 자바 코드 삽입(용도 : 출력)  
 
   => 서블릿은 최초 한 번만 실행시키면 클래스 파일이 이미 존재하는 상황이 되지만  
   jsp 는 호출할 때마다 클래스를 만들고 객체를 만들고, 이를 반복함  


4. 컴파일: 작성한 소스 코드(.java)는 자바 컴파일러의 컴파일 과정을 통해  
   자바가상머신(JVM)이 인식할 수 있는 바이트 코드를 생성해내고  
   이렇게 만들어진 파일(.class)을 자바런처가 execute(실행)하게 되는 것이다.  
   
   빌드: 클래스 파일을 실행히 줄 수 있도록 여러 개의 클래스는 묶어서  
   하나의 실행 파일로 만들어 주는 과정이 빌드이다.  
   이클립스는 컴파일과 빌드를 한 번에 해주는 것이다.  


5. .jar  
라이브러리 파일  
자바 패키지의 집합으로 압축된 파일  
이 파일만은 유일하게 자바에서 스스로 압축을 해제하여 사용하게 된다.  


6. src  
확장자가 .java 인 파일들은 모조리 여기 위치한다.  


7. WebContent
- META-INF : 여기에는 context.xml 만 들어간다. 리소스의 위치를 저장하는 역할을 하게 되며, 주로 DB연동 시 사용된다.
- WEB-INF : 여기에는 web.xml 이 들어간다. 이에는 설정(배치기술서) 내용이 포함된다. (lib = 외부 라이브러리)


8. jsp 내장 객체  
request : 내장 객체  
response : 내장 객체  
session : 내장 객체  


9. servlet  
request : doGet() 과 doPost()의 매개변수  
response : doGet() 과 doPost()의 매개변수  
session : request.getSession() 으로 만들어서 사용 필요  


10. servlet을 만들고 request 객체를 공유할 수 있도록 작성하는 방법  

Servlet  
{  
   HttpServletRequest request;  //멤버 변수로 request 를 구성해두면 된다  
  
   void doGet(HttpServletRequest request)  
   {  
      this.request = request;  
   }  
}  


11. 데이터 전송 : HTML / JSP -> Servlet  
서블릿 파일은 HttpServletRequest객체를 이용하여, Parameter값을 얻음.  
파라미터 이외에는 데이터 전송과 관련한 다른 선택 가능한 수단이 없다. 파라미터는 곧 주소다.  

<관련 메소드>  
getParameter(name)  
: 웹 브라우저에서 전송받은 request 영역에서 name 값이 param인 값이 읽어옴  
getParameterValues(name)  
: check박스와 같이 하나의 name으로 여러개의 정보가 전달되어 올 때 사용  
getParameterNames()  
: 파라미터의 이름 집합을 Enumeration 객체로 반환, 전체 파라미터를 쉽게 다룰 수 있음  

예시)  
public void doPost(HttpServletRequest request, HttpServletResponse response){  
	String id = request.getParameter("id");  
	String pw = request.getParameter("pw");  
  
	response.setContentType("text/html; charset=EUC-KR");  
}  


12. 데이터 전송 : Servlet -> JSP  
애트리뷰트(attribute)를 이용한다.  
이 과정에서 파라미터는 잘 사용되지 않는다.  
  
<처리 과정>  
데이터 전송  
request.setAttribute("속성명", 데이터);   
session.setAttribute("속성명", 데이터)  

<처리>  
(변경할 타입명)request.getAttribute("속성명");  
(변경할 타입명)session.getAttribute("속성명");  

 
13. 패턴 Pattern  
-FrontController 패턴 : 여러 개의 요청을 하나의 Servlet 이 처리   

-Model 1 패턴 : 일반적으로 모든 코드를 JSP에 작성   

-Model 2 패턴 : 출력은 JSP가 수행하고, 처리는 Servlet이 수행. 유지보수가 쉽지만, 구조가 복잡함. 대규모 프로젝트에 이용  
 
-Command 패턴 : 각각의 요청을 별도의 객체가 처리  

-DAO 패턴 : 데이터베이스 연동 부분을 별도의 객체로 처리  

-DTO 패턴 : 데이터 표현을 별도의 객체로 처리  

-MVC 패턴 : 데이터를 만드는 부분(model)과 데이터를 출력하는 부분(view) 및 연결하는 부분(Controller)을 별도의 객체로 처리  
이 모든 과정은 독립성을 갖도록 해서 유지보수를 용이하게 하기 위해서 처리하는 것이다. 보통 Model2 MVC 패턴을 만든다.  









<0805>

1.JAVA의 특징  
: 플랫폼에 독립적인 객체지향언어  
  플랫폼에 독립적이라는 것은 리눅스 환경이나 윈도우 환경 등과 같은 개발환경에 제약받지 않고, 어느 플랫폼에서나 코드의 호환성과 재사용이 자유로움을 의미  
: 동적 로딩을 지원(객체가 필요한 시점에 클래스를 동적 로딩하여 생성)  
: 운영체제에 독립적 즉 프로그램을 다시 컴파일 할 필요 없이 실행 가능함  


2.JDK 1.5 부터 추가된 항목  
: 확장 for문, 비정형 인자, 제네릭, 오토박싱, 오토언박싱, 어노테이션 등  


3.Overloading(메소드 중복정의)과 Overriding(메소드 재정의)  
:오버로딩  
= 기존 메소드의 인자를 이용하여 하나의 함수에 여러 기능을 만드는 것  
:오버라이딩  
= 상위 클래스에 있는 메소드와 똑같은 메소드를 하위 클래스에서 다시 만드는 행위  
즉, 하위 클래스에서 메소드를 재정의하는 것을 말한다(다형성)  


4.객체(object)  
:클래스에 정의된 내용대로 메모리에 생성된 것  


5.클래스  
:객체를 만드는 설계도, 객체를 생성하는 틀  


6.객체와 인스턴스  
:클래스로부터 객체를 만드는 과정을 '클래스의 인스턴스화'라고 함  
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함  


7.객체 지향 프로그래밍(OOP, Object-Oriented Programming)  
:컴퓨터 프로그래밍의 패러다임의 하나임  
컴퓨터 프로그램을 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 함  
각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음  


8.캡슐화(Encapsulation)   
:하나의 문제를 해결하기 위한 데이터와 메소드를 하나의 단위로 묶는다는 것,  
클래스의 내부 정의에 대해 외부에서 볼 수 없도록 하는 것이 특징(은닉화)  


9.추상화(Abstraction)  
:모델(Object)의 자세한 성질을 숨기고 일반적인 성질을 나타낸다는 것으로서  
일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의  
공통적인 성질과 행위를 일반화하여 디자인 되게 되며,  
그로부터 생성된 객체는 자신의 고유의 성질을 가지게 됨.  


10.다형성(Polymorphism)  
:다형성이란 같은 메시지에 대해 클래스에 따라 다른 행위를 하게 되는 특징이다  
일반적으로 같은 이름을 가지는 메소드에 대해 인자(Argument)의 개수와 데이터형(Data Type)에 따라 수행되는 행위가 달라진다  
다형성을 통해서 사용자는 약속된 인터페이스를 따르는 서로 다른 객체를 같은 방식으로 사용할 수 있게 된다.  


11.매개변수 vs 인자  
:매개변수(파라미터 또는 parameter)는 함수 이름 뒤에 괄호안에 선언하는 변수이고,   
인자(인수 또는 argument)는 함수 호출시 전달하는 값을 말한다.   


12.상속(Inheritance)      
:기존에 있던 클래스를 바탕으로 다른 특성을 추가하여 새로운 클래스를 만들 수 있음     


13.인스턴스(Instance)      
:인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿(형식, 틀, 모형)이 실제 구현된 것  


14.예외 처리의 필요성과 목적  
-자바에서 프로그램의 실행 도중, 예외가 발생하면  
 발생된 그 시점에서 프로그램이 바로 종료된다.  
 하지만 가벼운 예외이거나 예상 가능한 예외의 경우일 수도 있으므로  
 '예외 처리'라는 수단이 제안되었고,  
 예외 처리를 통해 우선 프로그램의 비정상적인 종료를 막고  
 발생한 예외에 대한 처리로 정상적인 프로그램을 계속 진행할 수 있도록 하는 것이  
 예외 처리의 필요성이라 할 수 있다.  
-즉, 예외의 발생으로 실행 중인 프로그램의 갑작스러운 비정상 종료를 막고,  
 정상적인 실행 상태를 유지할 수 있도록 하는 것  


15.추상화  
:자바에서 공통의 속성, 기능을 묶어 이름을 붙이는 것을 의미한다  
자바에서 추상화는 추상클래스, 인터페이스를 통해 구현된다  


16.추상(abstract) 클래스  
:추상 메소드를 하나 이상 가지는 클래스  
:'new'로 객체를 생성할 수 없음  
:상속받은 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있음  
(추상 클래스끼리의 상속은 메소드 재정의가 필요 없음, 사용할 때 일반 클래스에서 재정의)  
-추상 메소드란, 함수의 리턴 타입과 파라미터만 있고 정의 부분이 없는 함수를 말함.  
:abstract class 클래스이름 { abstrack 반환타입 메소드이름(); }  


17.인터페이스  
-상수 또는 추상 메소드만 정의할 수 있음  
-구현된 메소드는 포함할 수 없음  
-모든 변수는 static이고 final 임  
-자식 클래스들이 공통된 메소드를 포함하도록 함  
-다중 상속이 가능함  


18.추상 클래스와 인터페이스의 공통점  
-객체를 발생시킬수 없음  
-상속하여 하위 클래스를 통해 객체를 발생시킨다.  
-메소드를 재정의해야 한다.  


19. 클래스 vs 메소드 vs 상수


20. JVM의 구성


21.'Collection'에서 데이터를 저장하는 3가지와 그 특징  
-set : 순서가 없고, 동일한 데이터 허용이 안 됨  
-list : 배열과 같은 구조지만, 가변적 길이를 가지고 있음(크기가 지정되어 있지 않음)  
-map : key 값과 value 값의 형식으로 저장되면 key 값은 절대 중복이 안 됨  


22.String vs StringBuffer vs StringBuilder  
-String 클래스 : 상수 문자열, 한번 생성한 후 변하지 않는 문자열 용도  
-StringBuffer 클래스 : 프로그램 내에서 계속 변하는 문자열 용도  
-StringBuilder 클래스 : StringBuilder 는 Java5에서 추가된 클래스로    
StringBuffer 와 기능이 같다.  
차이점은 스트링버퍼는 동기화가 되지만 스트링빌더는 그렇지 않다는 것이다.   
즉, 스트링빌더는 다중 thread 에서는 안전하지 않으므로  
동기화가 필요한 경우에는 스트링버퍼를 사용하는 것이 좋다.  
+스트링버퍼는 동기화를 하려면 synchronized 블록으로 감싸야 한다.  


23. thread


24. Stream이란?  
:데이터를 목적지로 입출력하기 위한 방법  
스트림에 데이터를 쓸 수 있고, 데이터를 읽을 수 있음  
:스트림은 FIFO(First In First Out)구조로 읽기와 쓰기가 동시에 되지 않음  
읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야 함  
데이터가 처리되기 이전 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지  
blocking(막는 것을 의미하며 입출력시 작업이 중단되는 것) 상태에 빠짐  


25.동기화  
: 여러 명이 접근하는 것을 방지  
: 여러 명이 접근하는 것을 막기 위해 모든 객체에 lock 을 포함하는데,  
lock 이란 공유 객체에 여러 thread가 동시에 접근하지 못하도록 하기 위한 것으로  
모든 객체가 Heap 영역에 생성될 때 자동으로 만들어진다.  


26. InnerClass vs OuterClass


27. Statement vs PreparedStatement
-Statement  
:정적 쿼리 시 사용  
매번 parsing(=구문 분석) 과정을 거쳐야 하므로 부하가 생길 수 있음  
SQL문 전체를 명확히 알 수 있어서 디버깅(=프로그래밍에서 잘못된 부분을 찾아 고치는 것)이 쉬움 

-PreparedStatement  
:동적 쿼리 시 사용  
한번 parsing하면 동일한 sql문장을 곧바로 파싱 과정 없이 실행(Execution)할 수 있음  
(반복적인 다량의 sql 수행 시 성능상 이득이 있음)  
오류 발생 시 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움   


28.정적 쿼리 vs 동적 쿼리


29.AWT vs Swing


30.Java Beans  
:자바에서 사용하는 컴포넌트  
Bean은 자바에서 컨포넌트를 이용하는 데 활용되는 기술  
컴포넌트를 사용하면 좋은 이유는 필요할 때마다 가져다가 사용할 수 있다는 점인데  
JSP에서 자바의 컴포넌트를 이용해서 프로그래밍하는 것을 빈즈 프로그래밍이라 함. 


31.컴포넌트


32.Connection Pool  
:미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념  
미리 생성할 때 너무 조금 생성하면 타임 오버헤드가 늘어나고,  
반대로 너무 많이 생성하면 메모리 오버헤드가 늘어난다.  


33. Singleton  
-프로그래밍 디자인 패턴  
-발전된 형태의 전역 변수 개념   
-프로그램상에서 두 번째 인스턴스를 만들 수 없게 하는 기능   
-만들어진 클래스의 객체를 단 하나만 사용하며 어디서든 그 객체를 사용할 수 있도록 만듬   


34.WAS(Web Application Server)  
-서버와 클라이언트 사이에 있는 3-tier 방식으로,   
Server가 처리하는 양이 많아지면서 Server 에 생기는 부하를 해결하기 위해 개발됨  
-Client 에서 요청이 들어오면 실제적인 처리는 WAS가 하고   
서버는 단지 Client 에 결과 값을 뿌려주는 역할만 하게 됨  
-대표적으로 톰캠, 웹스피어, 웹로직, 제우스 등이 있음   


35.미들웨어


36.서블릿(Servlet)  
-자바를 사용하여 웹페이지를 동적으로 생성하는 서버 측 프로그램  
-서버용 애플릿(초소형 응용프로그램), 웹서버에서 실행되는 작은 자바 코드  
JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함   
-웹브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름  
-웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용   


37.서블릿에서 데이터를 처리하는 방식  
-get  
:서버에 있는 정보를 가져오기 위해 설계됨  
240바이트까지 전달 가능  
post 방식에 비해 속도가 빠름  
url 노출로 보안성이 요구되는 경우엔 사용할 수 없음   
검색엔진에서 검색단어 전송에 많이 이용함  

-post  
:서버로 정보를 올리기 위해 설계됨  
데이터 크기의 제한이 없음   
get 방식에 비해 속도가 느림  
url 에 파라미터가 표시되지 않음, 내부적으로 데이터가 이동함   


38.JSP 에서 페이지 이동 방법  
(1) Forward 방식  
: url이 바뀌지 않음  
요청 객체와 응답 객체가 유지됨  
속도가 빠르며 '요청' 객체에 소속되어 있음  
-> 요청이 들어오면 Servlet이 받음  
-> 요청에 알맞은 페이지를 찾음, 알맞은 페이지가 있다면 응답  
-> 알맞은 페이지가 없다면 포워딩 방식으로 알맞은 페이지로 넘기는데, 요청 객체와   
응답 객체를 포함해서 넘김  
-> url 이 바뀌지 않은 상태로 응답 페이지를 통해 응답  

(2) Redirect 방식  
:url이 바뀜  
요청 객체와 응답 객체가 유지되지 않음  
속도가 느리며, '응답' 객체에 소속되어 있음  
-> 요청이 들어오면 Servlet이 받음   
-> 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답  
-> 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청하게끔 응답을 보냄   
-> 클라이언트는 응답을 받고, 다시 그 요청의 맞는 url로 요청함  


39.쿠키와 세션의 차이  
-쿠키  
: 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음.  
사라지는 시간을 지정할 수 있음. 
-세션  
: 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김.  
해당 클라이언트와 일정 시간 동안 작용이 없으면 서버 메모리에서 해제됨.  
직접적으로 해제시킬 수 있는 메소드가 있음  


40.JSP vs Javascript  
-JSP는 자바에서 파생된 서버 스크립트이며, 서버 사이드 스크립트로서 웹페이지를 작성함  
-자바스크립트는 클라이언트 사이트 스크립트이며, 브라우저의 객체를 제어하는 데 쓰임  

 
41.서블릿의 실행 과정  
1)서버가 클라이언트의 연결 요청을 받는다.  
2)웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를  
담고 있는 Response 객체를 생성한다.    
3)접수된 URL 을 분석 후 해당 서블릿 객체를 생성하고,  
사용자의 요청을 처리하기 위해 스레드를 생성 후 service() 메소드에 인자값을 담아 호출한다.  
4)service() 메소드는 Request 객체를 참고하여  
어떤 연결 요청 방식으로 들어왔는지 파악한다.  
5)get 방식은 doGet(), post 방식은 doPost() 메소드를 호출하여 처리한다.  
6)service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여준다.   
7)사용자 요청을 처리하기 위해 생성한 스레드를 소멸시킨다.  


42.서블릿 라이프 사이클(생명 주기)  
-서블릿은 javax.servlet.GenericServlet 클래스나 javax.servlet.HttpServlet 클래스를  
상속받아서 작성하며, init(), service(), destroy()의 세 개의 메소드에 의한 생명 주기를 갖는다.    
-서블릿이 로딩될 때 단 한 번 init() 메소드를 호출하게 되며  
클라이언트의 요청이 있을 때마다 service() 메소드를 반복적으로 호출하게 된다.  
서블릿 객체는 메모리를 해제하기 위해서 destroy() 메소드를 호출하게 된다.  


43.JSP 생명주기  
-초기화, 서비스, 파괴의 과정을 거친다.   
-jspInit() 메소드는 단 한번 호출하며 jspService() 메소드는 서비스 요청이 있을 때마다  
호출하게 된다. 즉, 클라이언트에서 jsp 문서를 클릭하게 되면 jsp 문서는 Servlet으로  
변환되고, 크 변환된 Servlet에서 처음으로 jspInit() 메소드가 호출된다.   


44.Jsp  
:Java Server Page    
자바를 기반으로 하는 스크립트 언어    
자바 언어를 기반으로 하고 있어서 플랫폼에 상관없이 사용 가능    
표현언어, 표현식, 스크립트릿 등의 다양한 스크릿트 요소와 액션 태그 등을  
제공함으로써 더 쉽게 웹 어플리케이션을 개발 가능  


45.Framework  
-특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의 집합  
-장점 : 재사용성, 단순성, 역할 구분, 확장성, 유지보수용이  
-프레임워크와 라이브러리 차이  
: 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음  
: 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공.

  
46.MVC 패턴  
-Model, View, Control 의 역할을 확실하게 분리해놓은 프로그래밍 기법    
-중간에 Controller 컴포넌트를 두어 비즈니스 로직과 데이터 접근 로직,  
프레젠테이션 로직을 분리한 디자인 패턴이다.  
-역할이 구분되어 모듈 간의 의존성을 낮추어  
재사용성 및 확장이 쉬운 구조이므로 유지보수에 유리하다.   
-모델1이 JSP 에 프레젠테이션 로직과 비즈니스 로직, 데이터 접근 로직이 함께  
들어갔던 반면 모델2는 각각의 역할을 나누어 작업을 분담한다.   
-뷰를 담당하는 JSP는 프레젠테이션 로직만을 처리하고  
컨트롤러는 요청을 어디로 보낼지 결정한다. 그리고 모델은 비즈니스 레이어에 포함된다.  


















